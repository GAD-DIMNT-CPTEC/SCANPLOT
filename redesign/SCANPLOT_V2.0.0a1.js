importScripts("https://cdn.jsdelivr.net/pyodide/v0.27.2/full/pyodide.js");

function sendPatch(patch, buffers, msg_id) {
  self.postMessage({
    type: 'patch',
    patch: patch,
    buffers: buffers
  })
}

async function startApplication() {
  console.log("Loading pyodide!");
  self.postMessage({type: 'status', msg: 'Loading pyodide'})
  self.pyodide = await loadPyodide();
  self.pyodide.globals.set("sendPatch", sendPatch);
  console.log("Loaded!");
  await self.pyodide.loadPackage("micropip");
  const env_spec = ['https://cdn.holoviz.org/panel/wheels/bokeh-3.6.3-py3-none-any.whl', 'https://cdn.holoviz.org/panel/1.6.1/dist/wheels/panel-1.6.1-py3-none-any.whl', 'pyodide-http==0.2.1', 'cartopy', 'geopandas', 'holoviews', 'hvplot', 'intake', 'matplotlib', 'numpy', 'pandas', 'param', 'requests', 'seaborn', 'xarray', 'yaml']
  for (const pkg of env_spec) {
    let pkg_name;
    if (pkg.endsWith('.whl')) {
      pkg_name = pkg.split('/').slice(-1)[0].split('-')[0]
    } else {
      pkg_name = pkg
    }
    self.postMessage({type: 'status', msg: `Installing ${pkg_name}`})
    try {
      await self.pyodide.runPythonAsync(`
        import micropip
        await micropip.install('${pkg}');
      `);
    } catch(e) {
      console.log(e)
      self.postMessage({
	type: 'status',
	msg: `Error while installing ${pkg_name}`
      });
    }
  }
  console.log("Packages loaded!");
  self.postMessage({type: 'status', msg: 'Executing code'})
  const code = `
  \nimport asyncio\n\nfrom panel.io.pyodide import init_doc, write_doc\n\ninit_doc()\n\n#!/usr/bin/env python\n# coding: utf-8\n\n# Usar o ambiente SCANPLOT_PANEL\n# @cfbastarz, Jun/2023 (carlos.bastarz@inpe.br)\n\nimport os\nimport io\nimport intake\nimport requests\nimport yaml\nimport xarray as xr\nimport numpy as np\nimport pandas as pd\nimport geopandas as gpd\nimport seaborn as sns\nimport panel as pn\nimport param\nimport hvplot.xarray\nimport hvplot.pandas\nimport hvplot as hv\nimport holoviews as hvs\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\n\nfrom datetime import datetime, timedelta\nfrom matplotlib import pyplot as plt\n\nhvs.extension('bokeh')\n\npn.extension('katex')\npn.extension('floatpanel')\npn.extension('texteditor')\npn.extension(notifications=True)\npn.extension(sizing_mode='stretch_width')\n\n# SCANPLOT_V2.0.0a1\n# @cfbastarz, Jun/2023 (carlos.bastarz@inpe.br)\n\nVars = [\n('VTMP:925', 'Virtual Temperature @ 925 hPa [K]'),\n('VTMP:850', 'Virtual Temperature @ 850 hPa [K]'),\n('VTMP:500', 'Virtual Temperature @ 500 hPa [K]'),\n('VTMP:250', 'Virtual Temperature @ 250 hPa [K]'),\n('VTMP:200', 'Virtual Temperature @ 200 hPa [K]'),\n('VTMP:150', 'Virtual Temperature @ 150 hPa [K]'),\n('VTMP:070', 'Virtual Temperature @ 70 hPa [K]'),\n('VTMP:050', 'Virtual Temperature @ 50 hPa [K]'),\n('TEMP:850', 'Absolute Temperature @ 850 hPa [K]'),\n('TEMP:500', 'Absolute Temperature @ 500 hPa [K]'),\n('TEMP:250', 'Absolute Temperature @ 250 hPa [K]'),\n('TEMP:200', 'Absolute Temperature @ 200 hPa [K]'),\n('TEMP:150', 'Absolute Temperature @ 150 hPa [K]'),\n('TEMP:070', 'Absolute Temperature @ 70 hPa [K]'),\n('TEMP:050', 'Absolute Temperature @ 50 hPa [K]'),\n('PSNM:000', 'Mean Sea Level Pressure [hPa]'),\n('UMES:925', 'Specific Humidity @ 925 hPa [g/Kg]'),\n('UMES:850', 'Specific Humidity @ 850 hPa [g/Kg]'),\n('UMES:500', 'Specific Humidity @ 500 hPa [g/Kg]'),\n('UMES:250', 'Specific Humidity @ 250 hPa [g/Kg]'),\n('UMES:200', 'Specific Humidity @ 200 hPa [g/Kg]'),\n('UMES:150', 'Specific Humidity @ 150 hPa [g/Kg]'),\n('UMES:070', 'Specific Humidity @ 70 hPa [g/Kg]'),\n('UMES:050', 'Specific Humidity @ 50 hPa [g/Kg]'),\n('AGPL:000', 'Inst. Precipitable Water @ 1000 hPa [Kg/m2]'),\n('ZGEO:850', 'Geopotential height @ 850 hPa [gpm]'),\n('ZGEO:500', 'Geopotential height @ 500 hPa [gpm]'),\n('ZGEO:250', 'Geopotential height @ 250 hPa [gpm]'),\n('UVEL:850', 'Zonal Wind @ 850 hPa [m/s]'),\n('UVEL:500', 'Zonal Wind @ 500 hPa [m/s]'),\n('UVEL:250', 'Zonal Wind @ 250 hPa [m/s]'),\n('UVEL:200', 'Zonal Wind @ 200 hPa [m/s]'),\n('UVEL:150', 'Zonal Wind @ 150 hPa [m/s]'),\n('UVEL:070', 'Zonal Wind @ 70 hPa [m/s]'),\n('UVEL:050', 'Zonal Wind @ 50 hPa [m/s]'),\n('VVEL:850', 'Meridional Wind @ 850 hPa [m/s]'),\n('VVEL:500', 'Meridional Wind @ 500 hPa [m/s]'),\n('VVEL:250', 'Meridional Wind @ 250 hPa [m/s]'),\n('VVEL:200', 'Meridional Wind @ 200 hPa [m/s]'),\n('VVEL:150', 'Meridional Wind @ 150 hPa [m/s]'),\n('VVEL:070', 'Meridional Wind @ 70 hPa [m/s]'),\n('VVEL:050', 'Meridional Wind @ 50 hPa [m/s]'), \n]    \n\nlist_var = [ltuple[0].lower() for ltuple in Vars]\n\ndate_range = '20191115122020020100'\n\ncolormaps = ['Accent',  'Blues',  'BrBG',  'BuGn',  'BuPu',  'CMRmap',  'Dark2',  'GnBu', \n             'Greens',  'Greys',  'OrRd',  'Oranges',  'PRGn',  'Paired',  'Pastel1', \n             'Pastel2',  'PiYG',  'PuBu', 'PuBuGn',   'PuOr',  'PuRd',  'Purples', \n             'RdBu',  'RdGy',  'RdPu',  'RdYlBu',  'RdYlGn',  'Reds',  'Set1', \n             'Set2',  'Set3',  'Spectral',  'Wistia',  'YlGn', 'YlGnBu',   'YlOrBr', \n             'YlOrRd',  'afmhot',  'autumn',  'binary',  'bone',  'brg',  'bwr', \n             'cividis',  'cool', \n             'coolwarm',  'copper',  'crest',  'cubehelix',  'flag',  'flare',  \n             'gist_earth',  'gist_gray',  'gist_heat',  'gist_ncar',   \n             'gist_stern',  'gist_yarg',  'gnuplot', 'gnuplot2',   'gray',  'hot',  'hsv', \n             'icefire',  'inferno',  'jet',  'magma',  'mako',  'nipy_spectral',  \n             'ocean',  'pink',  'plasma',  'prism',  'rainbow',  'rocket',  'seismic', \n             'spring',  'summer',  'tab10',  'tab20',  'tab20b',  'tab20c',  'terrain',  \n             'turbo',  'twilight',  'twilight_shifted',  'viridis',  'vlag',  'winter']\n\n#\n# Widgets\n#\n\n# Widgets Datas (das distribui\xe7\xf5es espaciais)\ndate = pn.widgets.DateSlider(name='Data', value=datetime(1970, 1, 1), start=datetime(1970, 1, 1), end=datetime(1970, 1, 2),format='%Y-%m-%d', disabled=True)\n#fcts = pn.widgets.IntSlider(name='Previs\xe3o (horas)', start=0, end=264, step=24, value=0)\n       \n# Widget de Notifica\xe7\xf5es\nsilence = pn.widgets.Toggle(name='\U0001f514 Silenciar Notifica\xe7\xf5es', button_type='primary', button_style='outline', value=False)\n\nread_catalog = pn.widgets.Button(name='\U0001f3b2 Ler Cat\xe1logo de Dados', button_type='primary')\nfile_input = pn.widgets.FileInput(name='Escolher Cat\xe1logo de Dados', accept='yml', mime_type='text/yml', multiple=False)\n\n# Widgets S\xe9rie Temporal (_st)    \nvarlev_st = pn.widgets.Select(name='Vari\xe1vel e N\xedvel', disabled=True)\nreg_st = pn.widgets.Select(name='Regi\xe3o', disabled=True)\nref_st = pn.widgets.Select(name='Refer\xeancia', disabled=True)\nexpt_st = pn.widgets.MultiChoice(name='Experimentos', disabled=True, solid=False)\n\n# Widgets Scorecard (_sc)\nTstats = ['Ganho Percentual', 'Mudan\xe7a Fracional']\ncolormap_sc = pn.widgets.Select(name='Cor do Preenchimento', value=colormaps[74], options=colormaps, disabled=True)\ninvert_colors_sc = pn.widgets.Checkbox(name='Inverter Cores', value=True, disabled=True)\n\nstatt_sc = pn.widgets.Select(name='Estat\xedstica', disabled=True)\ntstat = pn.widgets.Select(name='Tipo', disabled=True)\nreg_sc = pn.widgets.Select(name='Regi\xe3o', disabled=True)\nref_sc = pn.widgets.Select(name='Refer\xeancia', disabled=True)\nexpt1 = pn.widgets.Select(name='Experimento 1', disabled=True)\nexpt2 = pn.widgets.Select(name='Experimento 2', disabled=True)\n\n# Widgets Distribui\xe7\xe3o Espacial (_de) \nFills = ['image', 'contour']\nfill_de = pn.widgets.Select(name='Preenchimento', options=Fills, disabled=True)     \ncolormap_de = pn.widgets.Select(name='Cor do Preenchimento', value=colormaps[0], options=colormaps,  disabled=True)      \ninvert_colors_de = pn.widgets.Checkbox(name='Inverter Cores', value=True,  disabled=True) \n#interval = pn.widgets.IntInput(name='Intervalos', value=10, step=1, start=5, end=20, disabled=True)   \ninterval = pn.widgets.IntInput(name='Intervalos', disabled=False)#, visible=False)     \n    \nstate = pn.widgets.Select(name='Estat\xedstica', disabled=True)    \nvarlev_de = pn.widgets.Select(name='Vari\xe1vel e N\xedvel', disabled=True)    \nreg_de = pn.widgets.Select(name='Regi\xe3o', disabled=True)    \nref_de = pn.widgets.Select(name='Refer\xeancia', disabled=True)       \nexpe_de = pn.widgets.MultiChoice(name='Experimentos', disabled=True, solid=False)    \n      \n# Widgets Distribui\xe7\xe3o Espacial Double (_ded) \n#fill_ded = pn.widgets.Select(name='Preenchimento', value=Fills[0], options=Fills, disabled=True) \nfill_ded = pn.widgets.Select(name='Preenchimento', options=Fills, disabled=True)    \ncolormap_ded = pn.widgets.Select(name='Cor do Preenchimento', value=colormaps[80], options=colormaps, disabled=True)      \ninvert_colors_ded = pn.widgets.Checkbox(name='Inverter Cores', value=True, disabled=True) \nswipe_ded = pn.widgets.Checkbox(name='Juntar Figuras', value=False, disabled=True) \nshow_diff_ded = pn.widgets.Checkbox(name='Mostrar Diferen\xe7a', value=False, disabled=True) \n#interval_ded = pn.widgets.IntInput(name='Intervalos', disabled=True) \n\nvarlev_ded = pn.widgets.Select(name='Vari\xe1vel e N\xedvel', disabled=True)    \nreg_ded = pn.widgets.Select(name='Regi\xe3o', disabled=True)    \nref_ded = pn.widgets.Select(name='Refer\xeancia', disabled=True)    \nexpe_ded = pn.widgets.MultiChoice(name='Experimentos', disabled=True, solid=False)  \nexp1_ded = pn.widgets.Select(name='Experimento 1', disabled=True)\nexp2_ded = pn.widgets.Select(name='Experimento 2', disabled=True)\n\n# Vari\xe1vel l\xf3gica para determinar se o arquivo de cat\xe1logo j\xe1 foi lido (True) ou n\xe3o (False)\nloaded = pn.widgets.Checkbox(name='Cat\xe1logo Carregado', value=False, disabled=True)\n\n## Bot\xe3o da paleta de cores\nshow_color_pallete = pn.widgets.Button(name='\U0001f3a8 Paletas de Cores...', button_type='default')\n\n# Fun\xe7\xe3o callback do bot\xe3o 'Ler Cat\xe1logo de Dados' - nela, s\xe3o definidas todas as widgets\ndef readCatalog(event):\n    global data_catalog\n    \n    fname = os.path.join(os.getcwd(),'catalog.yml')\n    \n    try:\n        \n        # Abre o arquivo de cat\xe1logo para leitura das fontes de dados (utiliza o intake)\n        data_catalog = intake.open_catalog(os.path.join(os.getcwd(), 'catalog.yml'))\n\n        # Abre novamente o arquivo de cat\xe1logo para obter os metadados referente \xe0s datas (utiliza o yaml, n\xe3o \xe9 o ideal - mas por hora \xe9 o que faremos aqui...)\n        with open('catalog.yml', 'r') as file:\n            data_catalog_dates = yaml.safe_load(file)\n        file.close()\n\n        first_record = list(data_catalog_dates)[0]\n        tmp = data_catalog_dates[first_record]\n\n        date.start = datetime.strptime(str(data_catalog_dates['sources'][list(tmp)[0]]['metadata']['date_initial'][0]), '%Y%m%d%H')\n        fctd = data_catalog_dates['sources'][list(tmp)[0]]['metadata']['forecast_days'][0]\n        date_final = date.start + timedelta(days=int(fctd))\n        date.end = date_final\n        date.value = datetime.strptime(str(data_catalog_dates['sources'][list(tmp)[0]]['metadata']['date_initial'][0]), '%Y%m%d%H')\n        \n        date.disabled = False\n\n        if silence.value is False: pn.state.notifications.success('Cat\xe1logo carregado com sucesso!', duration=5000)\n        \n        loaded.value = True\n        \n        Regs = []\n        StatsE = []\n        StatsT = []\n        Exps = []\n        Refs = []\n        Types = []        \n        \n        # Para cada entrada no arquivo de cat\xe1logo, organiza os atributos\n        for source in data_catalog:\n            attrs = source.split('-')\n            Regs.append(attrs[1])\n            if attrs[5] == 'field':\n                StatsE.append(attrs[2].upper())\n            else:\n                StatsT.append(attrs[2].upper())\n                Exps.append(attrs[3].upper())\n                Refs.append(attrs[4])\n            Types.append(attrs[5])\n\n        # Widgets S\xe9rie Temporal (_st)\n        if Vars and 'table' in Types:\n            varlev_st.options = [i[0] for i in Vars]\n            varlev_st.value = [i[0] for i in Vars][0] #\n        if Regs and 'table' in Types:\n            reg_st.options = [*set(Regs)]\n            reg_st.value = [*set(Regs)][0] #\n        if Refs and 'table' in Types:\n            ref_st.options = [*set(Refs)]\n            ref_st.value = [*set(Refs)][0] #\n        if Exps and 'table' in Types:\n            expt_st.options = [*set(Exps)]\n            expt_st.value = [[*set(Exps)][0]]\n        \n        varlev_st.disabled = reg_st.disabled = ref_st.disabled = expt_st.disabled = False\n\n        # Widgets Scorecard (_sc)\n        if StatsT and 'table' in Types:\n            statt_sc.options = [*set(StatsT)]\n            statt_sc.value = [*set(StatsT)][0] #\n        if Tstats and 'table' in Types:\n            tstat.options = [*set(Tstats)]\n            tstat.value = [*set(Tstats)][0] #\n        if Regs and 'table' in Types:\n            reg_sc.options = [*set(Regs)]\n            reg_sc.value = [*set(Regs)][0] #\n        if Refs and 'table' in Types:\n            ref_sc.options = [*set(Refs)]\n            ref_sc.value = [*set(Refs)][0] #\n        if Exps and 'table' in Types:\n            expt1.options = [*set(Exps)]\n            expt1.value = [*set(Exps)][0]\n        if Exps and 'table' in Types:\n            expt2.options = [*set(Exps)]\n            #expt2.value = [*set(Exps)][1]\n            expt2.value = [*set(Exps)][0]\n        invert_colors_sc.value = True\n\n        statt_sc.disabled = tstat.disabled = reg_sc.disabled = ref_sc.disabled = False\n        expt1.disabled = expt2.disabled = False       \n        colormap_sc.disabled = invert_colors_sc.disabled = False\n    \n        # Widgets Distribui\xe7\xe3o Espacial (_de) \n        if StatsE and 'field' in Types:\n            state.options = [*set(StatsE)]\n            state.value = [*set(StatsE)][0] #\n        if Vars and 'field' in Types:\n            varlev_de.options = [i[0] for i in Vars]\n            varlev_de.value = [i[0] for i in Vars][0] #\n        if Regs and 'field' in Types:\n            reg_de.options = [*set(Regs)]\n            reg_de.value = [*set(Regs)][0] #\n        if Refs and 'field' in Types:\n            ref_de.options = [*set(Refs)]\n            ref_de.value = [*set(Refs)][0] #\n        if Exps and 'field' in Types:\n            expe_de.options = [*set(Exps)]\n            expe_de.value = [[*set(Exps)][0]]\n        fill_de.value = Fills[0]\n        fill_de.options = Fills         \n\n        state.disabled = varlev_de.disabled = reg_de.disabled = ref_de.disabled = expe_de.disabled = False\n        fill_de.disabled = colormap_de.disabled = invert_colors_de.disabled = False\n\n        # Widgets Distribui\xe7\xe3o Espacial Double (_ded) \n        if Vars and 'field' in Types:\n            varlev_ded.options = [i[0] for i in Vars]\n            varlev_ded.value = [i[0] for i in Vars][0] #\n        if Regs and 'field' in Types:\n            reg_ded.options = [*set(Regs)]\n            reg_ded.value = [*set(Regs)][0] #\n        if Refs and 'field' in Types:\n            ref_ded.options = [*set(Refs)]\n            ref_ded.value = [*set(Refs)][0] #\n        if Exps and 'field' in Types:\n            expe_ded.options = [*set(Exps)]\n            expe_ded.value = [[*set(Exps)][0]]\n        if Exps and 'field' in Types:\n            exp1_ded.options = [*set(Exps)]\n            exp1_ded.value = [*set(Exps)][0]\n        if Exps and 'field' in Types:\n            exp2_ded.options = [*set(Exps)]\n            #exp2_ded.value = [*set(Exps)][1]\n            exp2_ded.value = [*set(Exps)][0]\n        fill_ded.value = Fills[0]\n        fill_ded.options = Fills    \n       \n        interval.value = 10\n        interval.step = 1\n        interval.start = 5\n        interval.end = 20      \n\n        #print(fill_de.value, fill_ded.value)\n\n        #if fill_de.value == 'contour' or fill_ded.value == 'contour':\n        #    interval.disabled = False\n        #    #interval.visible = True\n        #else:\n        #    interval.disabled = True\n        #    #interval.visible = False\n\n        varlev_ded.disabled = reg_ded.disabled = ref_ded.disabled = expe_ded.disabled = exp1_ded.disabled = exp2_ded.disabled = False      \n        invert_colors_ded.disabled = swipe_ded.disabled = show_diff_ded.disabled = fill_ded.disabled = colormap_ded.disabled = False \n\n        read_catalog.visible = False\n  \n    except IOError:\n        \n        if silence.value is False: pn.state.notifications.error('Arquivo ' + fname + ' n\xe3o existe!', duration=5000) \n    \nread_catalog.on_click(readCatalog)     \n\nwinpt = pn.Column(file_input, read_catalog, loaded)    \nwst = pn.Column(varlev_st, reg_st, ref_st, expt_st)\nwsc = pn.Column(statt_sc, tstat, reg_sc, ref_sc, expt1, expt2, pn.Column(colormap_sc, show_color_pallete), invert_colors_sc)\nwde = pn.Column(fill_de, state, varlev_de, reg_de, ref_de, colormap_de, invert_colors_de, interval, expe_de)\n#wded = pn.Column(fill_ded, varlev_ded, reg_ded, ref_ded, colormap_ded, invert_colors_ded, expe_ded, swipe_ded, show_diff_ded, exp1_ded, exp2_ded)\nwded = pn.Column(state, varlev_ded, reg_ded, ref_ded, exp1_ded, exp2_ded, date, fill_ded, pn.Column(colormap_ded, show_color_pallete), invert_colors_ded, interval, swipe_ded, show_diff_ded)\n\n@pn.depends(file_input, watch=True)\ndef save(value):\n    if file_input.value is not None:\n        file_input.save(os.path.join(os.getcwd(),'catalog.yml'))\n        if silence.value is False: pn.state.notifications.success('Arquivo catalog.yml salvo com sucesso!', duration=5000)\n    else:\n        if silence.value is False: pn.state.notifications.warning('Nenhum arquivo para salvar.', duration=5000)\n\n#\n# Fun\xe7\xf5es de plotagem\n#\n\ndef get_min_max_ds(ds):\n    return ds.compute().min().item(), ds.compute().max().item()\n\ndef get_df(reg, exp, stat, ref, varlev):\n    kname = 'scantec-' + reg + '-' + stat + '-' + exp.lower() + '-' + ref + '-table'\n    if data_catalog is not None:\n        # Verifica se a fonte de dados existe no cat\xe1logo\n        if kname in data_catalog:\n            df = data_catalog[kname].read()\n            df.set_index('Unnamed: 0', inplace=True)\n            df.index.name = '' \n        else:\n            # Se a fonte de dados n\xe3o existir, retorna um dataframe vazio\n            df = pd.DataFrame(columns=['%Previsao', varlev])\n            #df.set_index('Unnamed: 0', inplace=True)\n            df.index.name = '' \n        return df\n\n@pn.depends(varlev_st, reg_st, ref_st, expt_st, loaded)\ndef plotCurves(varlev_st, reg_st, ref_st, expt_st, loaded):\n    \n    if loaded and varlev_st and reg_st and ref_st and expt_st:       \n        \n        for i in Vars:\n            if i[0] == varlev_st:\n                nexp_ext = i[1]\n\n        varlev_st = varlev_st.lower()\n\n        height=500    \n        \n        for count, i in enumerate(expt_st):\n            if count == 0:\n                exp = expt_st[count] \n            \n                df_vies = get_df(reg_st, exp, 'vies', ref_st, varlev_st)\n            \n                if df_vies is not None:\n            \n                    ax_vies = df_vies.hvplot.line(x='%Previsao',\n                                          y=varlev_st,\n                                          xlabel='Horas',\n                                          ylabel='VIES',\n                                          shared_axes=False,\n                                          grid=True,\n                                          line_width=3,\n                                          label=str(exp),\n                                          fontsize={'ylabel': '12px', 'ticks': 10},\n                                          responsive=True,\n                                          height=height,\n                                          title='VIES' + ' - ' + str(nexp_ext))\n            \n                    df_rmse = get_df(reg_st, exp, 'rmse', ref_st, varlev_st)\n        \n                    ax_rmse = df_rmse.hvplot.line(x='%Previsao',\n                                          y=varlev_st,\n                                          xlabel='Horas',\n                                          ylabel='RMSE',\n                                          shared_axes=False,\n                                          grid=True,\n                                          line_width=3,\n                                          label=str(exp),\n                                          fontsize={'ylabel': '12px', 'ticks': 10},\n                                          responsive=True,\n                                          height=height,\n                                          title='RMSE' + ' - ' + str(nexp_ext))            \n                        \n                    df_acor = get_df(reg_st, exp, 'acor', ref_st, varlev_st)\n            \n                    ax_acor = df_acor.hvplot.line(x='%Previsao', \n                                          y=varlev_st,\n                                          xlabel='Horas',\n                                          ylabel='ACOR',\n                                          shared_axes=False,\n                                          grid=True,\n                                          line_width=3,\n                                          label=str(exp),\n                                          fontsize={'ylabel': '12px', 'ticks': 10},     \n                                          responsive=True,\n                                          height=height,\n                                          title='ACOR' + ' - ' + str(nexp_ext))  \n            \n            else:\n            \n                exp = expt_st[count]\n            \n                df_vies = get_df(reg_st, exp, 'vies', ref_st, varlev_st)\n            \n                if df_vies is not None:\n            \n                    ax_vies *= df_vies.hvplot.line(x='%Previsao', \n                                           y=varlev_st, \n                                           xlabel='Horas', \n                                           ylabel='VIES',\n                                           shared_axes=False,\n                                           grid=True,\n                                           line_width=3,\n                                           label=str(exp),  \n                                           fontsize={'ylabel': '12px', 'ticks': 10},\n                                           responsive=True,\n                                           height=height,\n                                           title='VIES' + ' - ' + str(nexp_ext))\n            \n                    df_rmse = get_df(reg_st, exp, 'rmse', ref_st, varlev_st)\n            \n                    ax_rmse *= df_rmse.hvplot.line(x='%Previsao',\n                                           y=varlev_st,\n                                           xlabel='Horas',\n                                           ylabel='RMSE', \n                                           shared_axes=False,\n                                           grid=True,\n                                           line_width=3,\n                                           label=str(exp), \n                                           fontsize={'ylabel': '12px', 'ticks': 10},\n                                           responsive=True,\n                                           height=height,\n                                           title='RMSE' + ' - ' + str(nexp_ext))       \n\n                    df_acor = get_df(reg_st, exp, 'acor', ref_st, varlev_st)\n            \n                    ax_acor *= df_acor.hvplot.line(x='%Previsao',\n                                           y=varlev_st,\n                                           xlabel='Horas',\n                                           ylabel='ACOR', \n                                           shared_axes=False,\n                                           grid=True,\n                                           line_width=3,\n                                           label=str(exp),      \n                                           fontsize={'ylabel': '12px', 'ticks': 10},\n                                           responsive=True,\n                                           height=height,\n                                           title='ACOR' + ' - ' + str(nexp_ext))             \n       \n            if ax_vies is not None:\n                ax_vies *= hvs.HLine(0).opts(line_width=1, shared_axes=False, responsive=True, height=height, line_color='black', line_dash='dashed')\n                ax_rmse *= hvs.HLine(0).opts(line_width=1, shared_axes=False, responsive=True, height=height, line_color='black', line_dash='dashed')\n                ax_acor *= hvs.HLine(0.6).opts(line_width=1, shared_axes=False, responsive=True, height=height, line_color='black', line_dash='dashed')    \n            \n\n        if ax_vies is not None:\n            ax_vies.opts(axiswise=True, legend_position='bottom_left')\n            ax_rmse.opts(axiswise=True, legend_position='top_left')\n            ax_acor.opts(axiswise=True, legend_position='bottom_left')\n    \n        layout = hvs.Layout(ax_vies + ax_rmse + ax_acor).cols(3)\n    \n    else:\n        \n        layout = pn.Column(\n                    pn.pane.Markdown("""\n                    # S\xe9rie Temporal\n                    \n                    A avalia\xe7\xe3o por meio de s\xe9rie temporal permite verificar o comportamento de par\xe2metros (vari\xe1veis) do modelo ao longo do tempo, seja por meio da verifica\xe7\xe3o dos erros aleat\xf3rios, sistem\xe1ticos e habilidade de previs\xe3o.\n                    """),\n                    pn.pane.Alert('\u26d4 **Aten\xe7\xe3o:** Nada para mostrar! Para come\xe7ar, selecione um cat\xe1logo de dados ou aguarde a execu\xe7\xe3o da fun\xe7\xe3o de plotagem.', alert_type='danger')\n                )\n    \n    return layout\n    \n@pn.depends(statt_sc, tstat, reg_sc, ref_sc, expt1, expt2, colormap_sc, invert_colors_sc, loaded)    \ndef plotScorecard(statt_sc, tstat, reg_sc, ref_sc, expt1, expt2, colormap_sc, invert_colors_sc, loaded):\n    \n    if loaded and statt_sc and tstat and reg_sc and ref_sc and expt1 and expt2 and colormap_sc:# and invert_colors_sc:   \n    \n        dfs = globals()['data_catalog']\n    \n        kname1 = 'scantec-' + reg_sc + '-' + statt_sc.lower() + '-' + expt1.lower() + '-' + ref_sc + '-table'\n        kname2 = 'scantec-' + reg_sc + '-' + statt_sc.lower() + '-' + expt2.lower() + '-' + ref_sc + '-table'\n    \n        df1 = dfs[kname1].read()\n        df2 = dfs[kname2].read()\n        \n        df1.set_index('Unnamed: 0', inplace=True)\n        df1.index.name = ''   \n\n        df2.set_index('Unnamed: 0', inplace=True)\n        df2.index.name = ''      \n        \n        p_table1 = pd.pivot_table(df1, index='%Previsao', values=list_var)\n        p_table2 = pd.pivot_table(df2, index='%Previsao', values=list_var)\n \n        if invert_colors_sc == True:\n            cmap = colormap_sc + '_r'\n        else:\n            cmap = colormap_sc\n\n        if tstat == 'Ganho Percentual':\n            # Porcentagem de ganho\n            if statt_sc == 'ACOR':\n                #score_table = ((p_table2[1:].T - p_table1[1:].T) / (1.0 - p_table1[1:].T)) * 100\n                score_table = ((p_table2.T - p_table1.T) / (1.0 - p_table1.T)) * 100\n            elif statt_sc == 'RMSE' or statt_sc == 'VIES':\n                #score_table = ((p_table2[1:].T - p_table1[1:].T) / (0.0 - p_table1[1:].T)) * 100\n                score_table = ((p_table2.T - p_table1.T) / (0.0 - p_table1.T)) * 100\n        elif tstat == 'Mudan\xe7a Fracional':\n            # Mudan\xe7a fracional\n            #score_table = (1.0 - (p_table2[1:].T / p_table1[1:].T))\n            score_table = (1.0 - (p_table2.T / p_table1.T))\n \n        if score_table.isnull().values.any():\n\n            # Tentativa de substituir os NaN - que aparecem quando vies e rmse s\xe3o iguais a zero\n            score_table = score_table.fillna(0.0000001)\n\n            # Tentativa de substituir valores -inf por um n\xfamero n\xe3o muito grande\n            score_table.replace([np.inf, -np.inf], 1000000, inplace=True)\n\n            if silence.value is False: pn.state.notifications.info('Valores como NaN ou Inf podem ter sido substitu\xeddos por outros valores.', duration=5000) \n\n        ## Figura\n        plt.figure(figsize = (9,6))\n\n        sns.set(style='whitegrid', font_scale=0.450)\n        sns.set_context(rc={'xtick.major.size':  1.5,  'ytick.major.size': 1.5,\n                            'xtick.major.pad':   0.05,  'ytick.major.pad': 0.05,\n                            'xtick.major.width': 0.5, 'ytick.major.width': 0.5,\n                            'xtick.minor.size':  1.5,  'ytick.minor.size': 1.5,\n                            'xtick.minor.pad':   0.05,  'ytick.minor.pad': 0.05,\n                            'xtick.minor.width': 0.5, 'ytick.minor.width': 0.5})\n\n        if tstat == 'Ganho Percentual':\n            ax = sns.heatmap(score_table, annot=True, fmt='.3f', cmap=cmap, \n                             vmin=-100, vmax=100, center=0, linewidths=0.25, square=False,\n                             cbar_kws={'shrink': 1.0, \n                                       'ticks': np.arange(-100,110,10),\n                                       'pad': 0.01,\n                                       'orientation': 'vertical'})\n\n            cbar = ax.collections[0].colorbar\n            cbar.set_ticks([-100, -50, 0, 50, 100])\n            cbar.set_ticklabels(['pior', '-50%', '0', '50%', 'melhor'])\n            cbar.ax.tick_params(labelsize=7)    \n\n            plt.title('Ganho ' + str(statt_sc) + ' (%) - ' + expt1 + ' Vs. ' + expt2, fontsize=8)\n\n        elif tstat == 'Mudan\xe7a Fracional':\n            ax = sns.heatmap(score_table, annot=True, fmt='.3f', cmap=cmap, \n                             vmin=-1, vmax=1, center=0, linewidths=0.25, square=False,\n                             cbar_kws={'shrink': 1.0, \n                                       'ticks': np.arange(-1,2,1),\n                                       'pad': 0.01,\n                                       'orientation': 'vertical'})\n\n            cbar = ax.collections[0].colorbar\n            cbar.set_ticks([-1, -0.5, 0, 0.5, 1])\n            cbar.set_ticklabels(['pior', '-0.5', '0', '0.5', 'melhor'])\n            cbar.ax.tick_params(labelsize=7)    \n\n            plt.title('Mudan\xe7a Fracional ' + str(statt_sc) + " - " + expt1 + ' Vs. ' + expt2, fontsize=8)\n\n        plt.xlabel('Horas de Integra\xe7\xe3o')\n        plt.yticks(fontsize=7)\n        #plt.xticks(rotation=90, fontsize=6)    \n        plt.xticks(fontsize=7)  \n        plt.tight_layout()        \n\n        layout = ax.get_figure()\n\n        plt.close()\n\n    else:\n        \n        layout = pn.Column(\n                    pn.pane.Markdown("""\n                    # Scorecard\n                    \n                    Para uma vari\xe1vel alpha (e.g., press\xe3o, temperatura, umidade, componentes do vento etc.), podem ser calculadas duas m\xe9tricas que permitem quantificar a varia\xe7\xe3o relativa entre dois experimentos avaliados pelo SCANTEC. As m\xe9tricas aplicadas s\xe3o o Ganho Percentual e a Mudan\xe7a Fracional e ambas podem ser calculadas com base nas tabelas de estatisticas do SCANTEC. Estas m\xe9tricas podem ser utilizadas quando se quiser ter uma vis\xe3o imediata sobre as melhorias obtidas entre duas vers\xf5es de um modelo ou entre dois experimentos de um mesmo modelo.\n                    """),\n                    pn.pane.Alert('\u26d4 **Aten\xe7\xe3o:** Nada para mostrar! Para come\xe7ar, selecione um cat\xe1logo de dados ou aguarde a execu\xe7\xe3o da fun\xe7\xe3o de plotagem.', alert_type='danger')\n                )        \n        \n    return layout\n\n@pn.depends(state, varlev_de, reg_de, ref_de, date, colormap_de, invert_colors_de, interval, expe_de, fill_de)\ndef plotFields(state, varlev_de, reg_de, ref_de, date, colormap_de, invert_colors_de, interval, expe_de, fill_de):\n    \n    if loaded and state and varlev_ded and reg_ded and ref_ded and date and colormap_ded and interval and fill_de and exp1_ded and exp2_ded:\n\n        date = str(date) + ' 12:00' # consertar...\n\n        var = varlev_de.replace(':', '').lower()\n        \n        for i in Vars:\n            if i[0] == varlev_de:\n                nexp_ext = i[1]\n        \n        if invert_colors_de == True:\n            cmap = colormap_de + '_r'\n        else:\n            cmap = colormap_de\n        \n        if reg_de == 'as':\n            data_aspect=1\n            frame_height=700\n        elif (reg_de == 'hn') or (reg_de == 'hs'):\n            data_aspect=1\n            frame_height=225        \n        elif reg_de == 'tr':\n            data_aspect=1\n            frame_height=150         \n        elif reg_de == 'gl': \n            data_aspect=1\n            frame_height=590\n    \n        for count, i in enumerate(expe_de):\n            if count == 0:\n                exp = expe_de[count]\n                kname = 'scantec-' + reg_de + '-' + state.lower() + '-' + exp.lower() + '-' + ref_de + '-field'\n                if data_catalog is not None:\n                    ds = data_catalog[kname].to_dask()\n                \n                vmin, vmax = get_min_max_ds(ds[var])\n                        \n                if fill_de == 'image':\n                \n                    #interval.disabled = True\n\n                    ax = ds.sel(time=date).hvplot.image(x='lon',\n                                                        y='lat',\n                                                        z=var,\n                                                        data_aspect=data_aspect,\n                                                        frame_height=frame_height, \n                                                        cmap=cmap, \n                                                        projection=ccrs.PlateCarree(), \n                                                        coastline=True,\n                                                        rasterize=True,\n                                                        clim=(vmin,vmax),\n                                                        title=str(state) + ' - ' + str(nexp_ext) + ' (' + str(date) + ')')    \n                    \n                elif fill_de == 'contour':\n                    \n                    #interval.disabled = False\n\n                    ax = ds.sel(time=date).hvplot.contour(x='lon',\n                                                        y='lat',\n                                                        z=var,\n                                                        data_aspect=data_aspect,\n                                                        frame_height=frame_height, \n                                                        cmap=cmap, \n                                                        projection=ccrs.PlateCarree(), \n                                                        coastline=True,\n                                                        rasterize=True,\n                                                        clim=(vmin,vmax),\n                                                        levels=interval,\n                                                        line_width=2,\n                                                        title=str(state) + ' - ' + str(nexp_ext) + ' (' + str(date) + ')')  \n                \n            else:  \n                \n                ax *= ds.sel(time=date).hvplot.contour(x='lon',\n                                                    y='lat',\n                                                    z=var,\n                                                    data_aspect=data_aspect,\n                                                    frame_height=frame_height, \n                                                    cmap=cmap, \n                                                    projection=ccrs.PlateCarree(), \n                                                    coastline=True,\n                                                    clim=(vmin,vmax),\n                                                    colorbar=True,\n                                                    levels=interval,\n                                                    line_width=4,\n                                                    line_dash='dashed',\n                                                    title=str(state) + ' - ' + str(nexp_ext) + ' (' + str(date) + ')') \n\n        layout = pn.Column(ax)\n\n    else:\n\n        layout = pn.Column(\n                    pn.pane.Markdown("""\n                    # Distribui\xe7\xe3o Espacial\n                    \n                    A avalia\xe7\xe3o por meio da distribui\xe7\xe3o espacial permite verificar o comportamento de par\xeametros (vari\xe1veis) do modelo ao longo do tempo, seja por meio da verifica\xe7\xe3o dos erros aleat\xf3rios, sistem\xe1ticos e habilidade de previs\xe3o.\n                    """),\n                    pn.pane.Alert('\u26d4 **Aten\xe7\xe3o:** Nada para mostrar! Para come\xe7ar, selecione um cat\xe1logo de dados ou aguarde a execu\xe7\xe3o da fun\xe7\xe3o de plotagem.', alert_type='danger')\n                ) \n\n    return layout\n\n@pn.depends(state, varlev_ded, reg_ded, ref_ded, date, colormap_ded, invert_colors_ded, interval, fill_ded, swipe_ded, show_diff_ded, exp1_ded, exp2_ded)\ndef plotFieldsDouble(state, varlev_ded, reg_ded, ref_ded, date, colormap_ded, invert_colors_ded, interval, fill_ded, swipe_ded, show_diff_ded, exp1_ded, exp2_ded):\n    \n    if loaded and state and varlev_ded and reg_ded and ref_ded and date and colormap_ded and interval and fill_ded and exp1_ded and exp2_ded:\n    \n        datefmt = str(date) + ' 12:00' # consertar...\n\n        var = varlev_ded.replace(':', '').lower()\n\n        for i in Vars:\n            if i[0] == varlev_ded:\n                nexp_ext = i[1]\n\n        if invert_colors_ded == True:\n            cmap = colormap_ded + '_r'\n        else:\n            cmap = colormap_ded\n\n        if reg_ded == 'as':\n            data_aspect=1\n            frame_height=800\n        elif (reg_ded == 'hn') or (reg_ded == 'hs'):\n            data_aspect=1\n            frame_height=235        \n        elif reg_ded == 'tr':\n            data_aspect=1\n            frame_height=155         \n        elif reg_ded == 'gl': \n            data_aspect=1\n            frame_height=340\n            frame_height=390\n\n        exp1 = exp1_ded\n        kname1 = 'scantec-' + reg_ded + '-' + state.lower() + '-' + exp1.lower() + '-' + ref_ded + '-field'\n        if data_catalog is not None:\n            ds1 = data_catalog[kname1].to_dask()\n\n        exp2 = exp2_ded\n        kname2 = 'scantec-' + reg_ded + '-' + state.lower() + '-' + exp2.lower() + '-' + ref_ded + '-field'\n        if data_catalog is not None:\n            ds2 = data_catalog[kname2].to_dask()\n\n        #vmin, vmax = get_min_max_ds(ds1[var])\n\n        if show_diff_ded:\n\n            #ds_diff = ds1[var].sel(time=datefmt) - ds2[var].sel(time=datefmt)\n            ds_diff = ds1[var].isel(time=0) - ds2[var].isel(time=0)\n\n            vmin, vmax = get_min_max_ds(ds_diff)\n\n            if fill_ded == 'image':\n\n                #interval.disabled = True\n\n                ax1 = ds1.sel(time=datefmt).hvplot.image(x='lon',\n                                                      y='lat',\n                                                      z=var,\n                                                      data_aspect=data_aspect,\n                                                      frame_height=frame_height, \n                                                      #frame_width=650,\n                                                      cmap=cmap, \n                                                      projection=ccrs.PlateCarree(), \n                                                      coastline=True,\n                                                      rasterize=True,\n                                                      #datashade=True,\n                                                      colorbar=True,\n                                                      #features=['borders', 'coastline', 'lakes', 'land', 'ocean', 'rivers', 'states'],   \n                                                      clim=(vmin,vmax),\n                                                      title=str(state) + ' - ' + str(exp1) + ' - ' + str(nexp_ext) + ' (' + str(datefmt) + ')')    \n\n                ax2 = ds2.sel(time=datefmt).hvplot.image(x='lon',\n                                                      y='lat',\n                                                      z=var,\n                                                      data_aspect=data_aspect,\n                                                      frame_height=frame_height, \n                                                      #frame_width=650,\n                                                      cmap=cmap, \n                                                      projection=ccrs.PlateCarree(), \n                                                      coastline=True,\n                                                      rasterize=True,\n                                                      #features=['borders', 'coastline', 'lakes', 'land', 'ocean', 'rivers', 'states'],\n                                                      #datashade=True,  \n                                                      colorbar=True,   \n                                                      clim=(vmin,vmax),\n                                                      title=str(state) + ' - ' + str(exp2) + ' - ' + str(nexp_ext) + ' (' + str(datefmt) + ')')         \n\n                axd = (ds1.sel(time=datefmt) - ds2.sel(time=datefmt)).hvplot.image(x='lon',\n                                                                                  y='lat',\n                                                                                  z=var,\n                                                                                  data_aspect=data_aspect,\n                                                                                  frame_height=frame_height, \n                                                                                  #frame_width=650,\n                                                                                  cmap=cmap, \n                                                                                  projection=ccrs.PlateCarree(), \n                                                                                  coastline=True,\n                                                                                  rasterize=True,\n                                                                                  #features=['borders', 'coastline', 'lakes', 'land', 'ocean', 'rivers', 'states'], \n                                                                                  #datashade=True,\n                                                                                  colorbar=True,\n                                                                                  clim=(vmin,vmax),\n                                                                                  title=str(state) + ' - ' + 'Dif. (' + str(exp1) + '-' + str(exp2) + ') - ' + str(nexp_ext) + ' (' + str(datefmt) + ')')    \n\n            elif fill_ded == 'contour':\n\n                #interval.disabled = False\n\n                ax1 = ds1.sel(time=datefmt).hvplot.contour(x='lon',\n                                                        y='lat',\n                                                        z=var,\n                                                        data_aspect=data_aspect,\n                                                        frame_height=frame_height, \n                                                        #frame_width=650,\n                                                        cmap=cmap, \n                                                        projection=ccrs.PlateCarree(), \n                                                        coastline=True,\n                                                        rasterize=True,\n                                                        #features=['borders', 'coastline', 'lakes', 'land', 'ocean', 'rivers', 'states'],\n                                                        clim=(vmin,vmax),\n                                                        levels=interval,\n                                                        line_width=1,\n                                                        title=str(state) + ' - ' + str(exp1) + ' - ' + str(nexp_ext) + ' (' + str(datefmt) + ')')    \n\n                ax2 = ds2.sel(time=datefmt).hvplot.contour(x='lon',\n                                                        y='lat',\n                                                        z=var,\n                                                        data_aspect=data_aspect,\n                                                        frame_height=frame_height, \n                                                        #frame_width=650,\n                                                        cmap=cmap, \n                                                        projection=ccrs.PlateCarree(), \n                                                        coastline=True,\n                                                        rasterize=True,\n                                                        #features=['borders', 'coastline', 'lakes', 'land', 'ocean', 'rivers', 'states'],\n                                                        clim=(vmin,vmax),\n                                                        levels=interval,\n                                                        line_width=1,\n                                                        title=str(state) + ' - ' + str(exp2) + ' - ' + str(nexp_ext) + ' (' + str(datefmt) + ')')                  \n\n                axd = (ds1.sel(time=datefmt) - ds2.sel(time=datefmt)).hvplot.contour(x='lon',\n                                                                                    y='lat',\n                                                                                    z=var,\n                                                                                    data_aspect=data_aspect,\n                                                                                    frame_height=frame_height, \n                                                                                    #frame_width=650,\n                                                                                    cmap=cmap, \n                                                                                    projection=ccrs.PlateCarree(), \n                                                                                    coastline=True,\n                                                                                    rasterize=True,\n                                                                                    #features=['borders', 'coastline', 'lakes', 'land', 'ocean', 'rivers', 'states'],\n                                                                                    #clim=(vmin,vmax),\n                                                                                    levels=interval,\n                                                                                    line_width=1,\n                                                                                    title=str(state) + ' - ' + str(exp1) + ' - ' + str(nexp_ext) + ' (' + str(datefmt) + ')')          \n        else:\n\n            vmin, vmax = get_min_max_ds(ds1[var])\n\n            if fill_ded == 'image':\n\n                #interval.disabled = True\n\n                ax1 = ds1.sel(time=datefmt).hvplot.image(x='lon',\n                                                      y='lat',\n                                                      z=var,\n                                                      data_aspect=data_aspect,\n                                                      frame_height=frame_height, \n                                                      #frame_width=650,\n                                                      cmap=cmap, \n                                                      projection=ccrs.PlateCarree(), \n                                                      coastline=True,\n                                                      rasterize=True,\n                                                      #datashade=True,\n                                                      colorbar=True,\n                                                      #features=['borders', 'coastline', 'lakes', 'land', 'ocean', 'rivers', 'states'],   \n                                                      clim=(vmin,vmax),\n                                                      title=str(state) + ' - ' + str(exp1) + ' - ' + str(nexp_ext) + ' (' + str(datefmt) + ')')    \n\n                ax2 = ds2.sel(time=datefmt).hvplot.image(x='lon',\n                                                      y='lat',\n                                                      z=var,\n                                                      data_aspect=data_aspect,\n                                                      frame_height=frame_height, \n                                                      #frame_width=650,\n                                                      cmap=cmap, \n                                                      projection=ccrs.PlateCarree(), \n                                                      coastline=True,\n                                                      rasterize=True,\n                                                      #features=['borders', 'coastline', 'lakes', 'land', 'ocean', 'rivers', 'states'],\n                                                      #datashade=True,  \n                                                      colorbar=True,   \n                                                      clim=(vmin,vmax),\n                                                      title=str(state) + ' - ' + str(exp2) + ' - ' + str(nexp_ext) + ' (' + str(datefmt) + ')')       \n\n            elif fill_ded == 'contour':\n\n                #interval.disabled = False\n\n                ax1 = ds1.sel(time=datefmt).hvplot.contour(x='lon',\n                                                        y='lat',\n                                                        z=var,\n                                                        data_aspect=data_aspect,\n                                                        frame_height=frame_height, \n                                                        #frame_width=650,\n                                                        cmap=cmap, \n                                                        projection=ccrs.PlateCarree(), \n                                                        coastline=True,\n                                                        rasterize=True,\n                                                        #features=['borders', 'coastline', 'lakes', 'land', 'ocean', 'rivers', 'states'],\n                                                        clim=(vmin,vmax),\n                                                        levels=interval,\n                                                        line_width=1,\n                                                        title=str(state) + ' - ' + str(exp1) + ' - ' + str(nexp_ext) + ' (' + str(datefmt) + ')')    \n\n                ax2 = ds2.sel(time=datefmt).hvplot.contour(x='lon',\n                                                        y='lat',\n                                                        z=var,\n                                                        data_aspect=data_aspect,\n                                                        frame_height=frame_height, \n                                                        #frame_width=650,\n                                                        cmap=cmap, \n                                                        projection=ccrs.PlateCarree(), \n                                                        coastline=True,\n                                                        rasterize=True,\n                                                        #features=['borders', 'coastline', 'lakes', 'land', 'ocean', 'rivers', 'states'],\n                                                        clim=(vmin,vmax),\n                                                        levels=interval,\n                                                        line_width=1,\n                                                        title=str(state) + ' - ' + str(exp2) + ' - ' + str(nexp_ext) + ' (' + str(datefmt) + ')')  \n\n        if show_diff_ded:    \n            #layout = pn.Column(ax1, ax2, axd, sizing_mode='stretch_width')\n            layout = pn.Column(axd, sizing_mode='stretch_width')\n            #if reg_ded == 'as':\n            #    layout = hvs.Layout(ax1 + ax2 + axd).cols(3)\n            #else:\n            #    layout = hvs.Layout(ax1 + ax2 + axd).cols(1)\n        else:\n            if swipe_ded:\n                layout = pn.Swipe(ax1, ax2, value=5)\n            else:\n                if reg_ded == 'as':# or reg_ded == 'gl':\n                    layout = hvs.Layout(ax1 + ax2).cols(2)\n                else:\n                    layout = hvs.Layout(ax1 + ax2).cols(1)\n\n        if silence.value is False: pn.state.notifications.info('As cores nos gr\xe1ficos podem representar intervalos de valores diferentes.', duration=5000)\n\n    else:\n\n        layout = pn.Column(\n                    pn.pane.Markdown("""\n                    # Distribui\xe7\xe3o Espacial\n                    \n                    A avalia\xe7\xe3o por meio da distribui\xe7\xe3o espacial permite verificar o comportamento de par\xeametros (vari\xe1veis) do modelo ao longo do tempo, seja por meio da verifica\xe7\xe3o dos erros aleat\xf3rios, sistem\xe1ticos e habilidade de previs\xe3o.\n                    """),\n                    pn.pane.Alert('\u26d4 **Aten\xe7\xe3o:** Nada para mostrar! Para come\xe7ar, selecione um cat\xe1logo de dados ou aguarde a execu\xe7\xe3o da fun\xe7\xe3o de plotagem.', alert_type='danger')\n                )           \n\n    return layout\n    \n@pn.depends(state, varlev_de, reg_de, ref_de, date, expt1)\ndef plotSeriesFromField(state, varlev_de, reg_de, ref_de, date, expt1):\n\n    var = varlev_de.replace(':', '').lower()\n    \n    kname = 'scantec-' + reg_de + '-' + state.lower() + '-' + expt1.lower() + '-' + ref_de + '-field'\n    if data_catalog is not None:\n        dsv = data_catalog['scantec-gl-rmse_exp18-ref_era5_no_clim-field'].to_dask()\n\n    source = dsv.isel(time=0).hvplot.image(x='lon',\n                                           y='lat',\n                                           z=var,\n                                           geo=True,\n                                           projection=ccrs.PlateCarree(),\n                                           title=str(state) + ' - ' + str(expt1) + ' (' + str(date) + ')')\n    \n    map_file = gpd.read_file(gpd.datasets.get_path('naturalearth_lowres'))\n\n    map_overlay = map_file.hvplot(geo=True, projection=ccrs.PlateCarree(), alpha=0.1)\n    \n    stream = hvs.streams.Tap(source=source, x=-88 + 360, y=40)\n    \n    def create_timeseries(x, y):\n        ds_sel = dsv.sel(lon=x, lat=y, method='nearest')\n        return hvs.Curve(ds_sel, ['time'], [var])\n    \n    target = hvs.DynamicMap(create_timeseries, streams=[stream]).opts(framewise=True, height=380, responsive=True)#, min_width=700)\n    \n    return pn.Row(source * map_overlay + target, sizing_mode='stretch_width')\n\n#\n# Textos\n#\n\ntext_gen_info = """\n# SCANPLOT\n\nSCANPLOT - Um sistema de visualiza\xe7\xe3o simples para o SCANTEC.\n\n## Experimentos:\n\n* **EXP18**: an\xe1lises e previs\xf5es do experimento com o SMNA em coordenada h\xedbrida na resolu\xe7\xe3o TQ0299L064;\n* **X666**: an\xe1lises e previs\xf5es do modelo BAM em coordenada h\xedbrida na resolu\xe7\xe3o TQ0666L064.\n\n## Validade:\n\nOs experimentos foram considerados para o per\xedodo de 2023021612 a 2023030312.\n\n## Avalia\xe7\xe3o:\n\nO SCANTEC foi utilizado para a avalia\xe7\xe3o objetiva dos experimentos com os seguintes ajustes:\n\n* Interpola\xe7\xe3o de todos os campos atmosf\xe9ricos para a resolu\xe7\xe3o 0,4 graus (lat/lon);\n* Utiliza\xe7\xe3o das seguintes refer\xeancias:\n    * \`ref_era5_no_clim\`: utiliza\xe7\xe3o das rean\xe1lises do Era5 como refer\xeancia e considerando a m\xe9dia temporal desta refer\xeancia como climatologia para o c\xe1lculo do Coeficiente de Correla\xe7\xe3o de Anomalias;\n    * \`ref_era5_no_clim\`: utiliza\xe7\xe3o das pr\xf3prias an\xe1lises dos experimentos como refer\xeancia e considerando a m\xe9dia temporal desta refer\xeancia como climatologia para o c\xe1lculo do Coeficiente de Correla\xe7\xe3o de Anomalias;\n    * \`ref_era5_cfsr_clim\` utiliza\xe7\xe3o das pr\xf3prias an\xe1lses dos experimentos como refer\xeancia e utiliza\xe7\xe3o da rean\xe1lise do CFSR como climatologia para o c\xe1lculo do Coeficiente de Correla\xe7\xe3o de Anomalias;\n    * \`ref_era5_agcm_clim\` utiliza\xe7\xe3o das pr\xf3prias an\xe1lses dos experimentos como refer\xeancia e utiliza\xe7\xe3o da climatologia do antigo MCGA para o c\xe1lculo do Coeficiente de Correla\xe7\xe3o de Anomalias. \n\n---\n\nAtualizado em: 29/06/2023 ([carlos.bastarz@inpe.br](mailto:carlos.bastarz@inpe.br))\n"""\n\n#text_vies1 = """\n## Vi\xe9s \n#\n#Para uma vari\xe1vel _alpha_ (e.g., press\xe3o, temperatura, umidade, componentes do vento etc.), discretizada em uma grade de _N_ pontos (com dimens\xf5es _i_ e _j_ - longitude e latitude, respectivamente, onde _N_ = _i_ x _j_), o Vi\xe9s \xe9 calculado de acordo com a equa\xe7\xe3o a seguir:\n#"""\n#\n#text_vies2 = """\n#onde,\n#\n#* \n#* \n#* \n#"""\n#\n#text_rmse1 = """\n## Raiz do Erro Quadr\xe1tico M\xe9dio\n#\n#Para uma vari\xe1vel _alpha_ (e.g., press\xe3o, temperatura, umidade, componentes do vento etc.), discretizada em uma grade de _N_ pontos (com dimens\xf5es _i_ e _j_ - longitude e latitude, respectivamente, onde _N_ = _i_ x _j_), a Raiz do Erro Quadr\xe1tico M\xe9dio \xe9 calculada de acordo com a equa\xe7\xe3o a seguir:\n#"""\n#\n#text_rmse2 = """\n#onde,\n#\n#* \n#* \n#* \n#"""\n#\n#text_acor1 = """\n## Coeficiente de Correla\xe7\xe3o de Anomalias\n#\n#O Coeficiente de Correla\xe7\xe3o de Anomalias \xe9 calculado de acordo com a equa\xe7\xe3o a seguir:\n#"""\n#\n#text_acor2 = """\n#onde,\n#\n#* \n#* \n#* \n#"""\n#\n#text_scor1 ="""\n## Scorecard\n#\n#Para uma vari\xe1vel alpha (e.g., press\xe3o, temperatura, umidade, componentes do vento etc.), podem ser calculadas duas m\xe9tricas que permitem quantificar a varia\xe7\xe3o relativa entre dois experimentos avaliados pelo SCANTEC. As m\xe9tricas aplicadas s\xe3o o Ganho Percentual e a Mudan\xe7a Fracional* e ambas podem ser calculadas com base nas tabelas de estatisticas do SCANTEC. Estas m\xe9tricas podem ser utilizadas quando se quiser ter uma vis\xe3o imediata sobre as melhorias obtidas entre duas vers\xf5es de um modelo ou entre dois experimentos de um mesmo modelo.\n#\n#O Ganho Percentual \xe9 definido por:\n#"""\n#\n#text_scor2 ="""\n#onde,\n#\n#* E1: tabelas do experimento 1;\n#* E2: tabelas do experimento 2;\n#* EP: experimento 'perfeito' (valor considerado quando o experimento \xe9 perfeito, ie., 0 quando Vi\xe9s ou RMSE e 1 quando ACOR).\n#\n#A Mudan\xe7a Fracional \xe9 definida por:\n#"""\n#\n#text_scor3 ="""\n#onde,\n#\n#* E1: tabelas do experimento 1;\n#* E2: tabelas do experimento 2;\n#* EP: experimento 'perfeito' (valor considerado quando o experimento \xe9 perfeito, ie., 0 quando Vi\xe9s ou RMSE e 1 quando ACOR).\n#\n#---\n#*[BA\xd1OS, I. H.](http://lattes.cnpq.br/6820161737155390); et al. **Impacto da Assimila\xe7\xe3o de Perfis de Refratividade do  Sat\xe9lite Metop-B nas Previs\xf5es de Tempo do CPTEC/INPE Durante os Meses de Janeiro e Agosto de 2014.** Dispon\xedvel em [link](https://www.scielo.br/scielo.php?script=sci_arttext&pid=S0102-77862018000100065).\n#"""  \n#\n#eq_ganho = pn.pane.Markdown(r'$$GP(\\alpha) = \\frac{E2 - E1}{EP - E1} \\times 100$$')\n#eq_mf = pn.pane.Markdown(r'$$MF(\\alpha) = 1 - \\frac{E2}{E1}$$')\n#eq_vies = pn.pane.Markdown(r'$$REQM(\\alpha) = \\frac{1}{N}\\sum_{n=1}^{N}\\bigg[ \\frac{1}{I \\cdot J}\\sum_{i=1}^{I}\\sum_{j=1}^{J}(\\alpha_{i,j,n}^{P} - \\alpha_{i,j,n}^{O})^{2} \\bigg]^\\frac{1}{2}$$')\n#eq_rmse = pn.pane.Markdown(r'$$REQM(\\alpha) = \\frac{1}{N}\\sum_{n=1}^{N}\\bigg[ \\frac{1}{I \\cdot J}\\sum_{i=1}^{I}\\sum_{j=1}^{J}(\\alpha_{i,j,n}^{P} - \\alpha_{i,j,n}^{O})^{2} \\bigg]^\\frac{1}{2}$$')\n#eq_cca = pn.pane.Markdown(r'$$CCA(\\alpha) = \\frac{\\sum\\limits_{i=1}^{I}\\sum\\limits_{j=1}^{J}\\big[ (\\alpha_{i,j}^{P} - \\alpha_{i,j}^{C})\\cdot(\\alpha_{i,j}^{A} - \\alpha_{i,j}^{C}) \\big]}{\\bigg \\lbrace \\bigg[ \\sum\\limits_{i=1}^{I}\\sum\\limits_{j=1}^{J}(\\alpha_{i,j}^{P} - \\alpha_{i,j}^{C})^2 \\bigg] \\bigg[ \\sum\\limits_{i=1}^{I}\\sum\\limits_{j=1}^{J}(\\alpha_{i,j}^{A} - \\alpha_{i,j}^{C})^2 \\bigg] \\bigg \\rbrace ^\\frac{1}{2}}$$')\n#eq_cca = pn.pane.Markdown(r"""\n#$$CCA(\\alpha) = \\frac{\\sum_{i=1}^{I}\\sum_{j=1}^{J}\\big[ (\\alpha_{i,j}^{P} - \\alpha_{i,j}^{C})\\cdot(\\alpha_{i,j}^{A} - \\alpha_{i,j}^{C}) \\big]}{\\bigg lbrace \\bigg[ \\sum_{i=1}^{I}\\sum_{j=1}^{J}(\\alpha_{i,j}^{P} - \\alpha_{i,j}^{C})^2 \\bigg] \\bigg[ \\sum_{i=1}^{I}\\sum_{j=1}^{J}(\\alpha_{i,j}^{A} - \\alpha_{i,j}^{C})^2 \\bigg] \\bigg \\}}\n#$$\n#""")\n\ntext_st = """\n# S\xe9rie Temporal\n\nA avalia\xe7\xe3o por meio de s\xe9rie temporal permite verificar o comportamento de par\xe2metros (vari\xe1veis) do modelo ao longo do tempo, seja por meio da verifica\xe7\xe3o dos erros aleat\xf3rios, sistem\xe1ticos e habilidade de previs\xe3o.\n"""\n\ntext_sc = """\n# Scorecard\n\nA avalia\xe7\xe3o por meio de scorecards permite obter uma vis\xe3o geral do comportamento de par\xe2metros (vari\xe1veis) do modelo ao longo do tempo.\n"""\n\ntext_ded = """\n# Distribui\xe7\xe3o Espacial\n\nA avalia\xe7\xe3o por meio da distribui\xe7\xe3o espacial permite verificar o comportamento de par\xeametros (vari\xe1veis) do modelo ao longo do tempo, seja por meio da verifica\xe7\xe3o dos erros aleat\xf3rios, sistem\xe1ticos e habilidade de previs\xe3o.\n"""\n\ntext_help = """\n# Ajuda\n\nClique sobre as abas \`S\xe9rie Temporal\`, \`Scorecard\` ou \`Distribui\xe7\xe3o Espacial\` para acessar as op\xe7\xf5es de plotagem e visualiza\xe7\xe3o das estat\xedsticas calculadas.\nCada tipo de visualiza\xe7\xe3o possui op\xe7\xf5es diferentes e independentes para a realiza\xe7\xe3o das plotagens. Utilize as op\xe7\xf5es para fazer os ajustes necess\xe1rios.\n"""\n\nscanplot_video = pn.pane.Video('https://s0.cptec.inpe.br/pesquisa/das/dist/carlos.bastarz/SCANPLOT/scanplot_video.mp4', width=600, muted=True, volume=0, loop=False)\n\nscanplot_imgs_fp = 'scanplot_imgs.png'\nscanplot_imgs = pn.pane.PNG(scanplot_imgs_fp, width=800)\n\nwelcomeText = pn.Column("""\n# Bem-vindo!\n\nEste \xe9 o SCANPLOT - Um sistema simples de plotagem para o SCANTEC. O SCANTEC - Sistema Comunit\xe1rio de Avalia\xe7\xe3o de modelos Num\xe9ricos de Tempo E Clima, \xe9 um sistema desenvolvido\npara a avalia\xe7\xe3o de modelos num\xe9ricos de previs\xe3o e clima em uso no CPTEC - Centro de Previs\xe3o de Tempo e Estudos Clim\xe1ticos. O SCANPLOT foi desenvolvido para uso exclusivo com \no SCANTEC, devido as suas particularidades de desenvolvimento e aplica\xe7\xe3o.\n\nPara come\xe7ar, clique no bot\xe3o \`Choose File\` (Escolher Arquivo) na barra lateral \xe0 esquerda e selecione um cat\xe1logo com os dados de avalia\xe7\xe3o realizada pelo SCANTEC. Em seguida, clique nas abas acima para acessar os resultados.\n\nSe precisar de ajuda, clique nos bot\xf5es da barra lateral \xe0 esquerda ou assista o v\xeddeo de introdu\xe7\xe3o ao uso do SCANPLOT a seguir. \n""", pn.Row(scanplot_video, scanplot_imgs))\n\ntext_fu = """\n# Selecionar Cat\xe1logo\n\nClique no bot\xe3o \`Choose File\` (Escolher Arquivo) na barra lateral \xe0 esquerda e selecione um cat\xe1logo com os dados de avalia\xe7\xe3o realizada pelo SCANTEC. Em seguida, clique nas abas acima para acessar os resultados.\n"""\n\ntext_float_panel = """\n# SCANPLOT V2.0.0a1\n\nSCANPLOT - Um sistema de visualiza\xe7\xe3o simples para o SCANTEC.\n\n---\n\nCPTEC-INPE, 2025.\n"""\n\n#\n# Layout\n#\n\n## Logos\nscantec_logo = 'https://raw.githubusercontent.com/GAM-DIMNT-CPTEC/SCANPLOT/8fe1c419bcb4881a78a3b1ac83673bcd229b075d/img/logo_scantec.png'\ninpe_logo = 'https://raw.githubusercontent.com/GAM-DIMNT-CPTEC/SCANPLOT/8fe1c419bcb4881a78a3b1ac83673bcd229b075d/img/logo_inpe.png'\n\nscantec_logo_fp = pn.pane.PNG(scantec_logo, width=200)\ninpe_logo = pn.pane.PNG(inpe_logo, width=200)\n\n## Pain\xe9is flutuantes e di\xe1logos modais\nconfig1 = {'headerControls':{'maximize': 'remove', 'smallify': 'remove'}\n         }\n\nconfig2 = {'headerControls': {'maximize': 'remove'}}\n\nfloat_panel = pn.layout.FloatPanel(\n    pn.Tabs(('Sobre',\n    pn.Row(text_float_panel, scantec_logo_fp)),\n           ('Reportar Bugs', 'Encontrou um bug? Abra uma issue no [GitHub do projeto](https://github.com/GAM-DIMNT-CPTEC/SCANPLOT/issues) ou envie um email para [carlos.bastarz@inpe.br](mailto:carlos.bastarz@inpe.br).'),\n           ('Contribuir', 'Quer contribuir com o desenvolvimento do SCANPLOT? Envie um email para [carlos.bastarz@inpe.br](mailto:carlos.bastarz@inpe.br).'),\n           ), \n    name='SCANPLOT', \n    contained=False, \n    position='center', \n    margin=20, \n    height=190,\n    config=config1)\n\n## Barra de ferramentas do editor de textos\ntoolbar=[\n  ['bold', 'italic', 'underline', 'strike'],        # toggled buttons\n  ['blockquote', 'code-block'],\n  [{ 'header': 1 }, { 'header': 2 }],               # custom button values\n  [{ 'list': 'ordered'}, { 'list': 'bullet' }],\n  [{ 'script': 'sub'}, { 'script': 'super' }],      # superscript/subscript\n  [{ 'indent': '-1'}, { 'indent': '+1' }],          # outdent/indent\n  [{ 'direction': 'rtl' }],                         # text direction\n  [{ 'size': ['small', False, 'large', 'huge'] }],  # custom dropdown\n  [{ 'header': [1, 2, 3, 4, 5, 6, False] }],\n  [{ 'color': [] }, { 'background': [] }],          # dropdown with defaults from theme\n  [{ 'font': [] }],\n  [{ 'align': [] }],\n  ['clean']                                         # remove formatting button\n]\n\n## Widget do editor de textos\neditor = pn.widgets.TextEditor(#mode='bubble',\n                               placeholder='Digitar texto...', \n                               #mode='bubble',\n                               toolbar=toolbar, \n                               margin=(0, 10, 0, 0), \n                               height=300, \n                               #width=50,\n                              )\n\n## Fun\xe7\xe3o para salvar o texto em um arquivo\ndef save_text(event):\n    with open("scanplot_text.txt", "w", encoding="utf-8") as f:\n        f.write(editor.value)\n    editor_save_btn_status.value = "Texto salvo com sucesso!"\n\n## Bot\xe3o salvar do editor de textos\neditor_save_btn = pn.widgets.Button(name='\U0001f4be Salvar', button_type='primary')\n\neditor_save_btn.on_click(save_text)\n\n# Indicador de status\neditor_save_btn_status = pn.pane.Markdown("")\n\n## Painel flutuante do editor de textos\ntext_editor = pn.layout.FloatPanel(pn.Column(editor, pn.Column(editor_save_btn, width=200), editor_save_btn_status),# sizing_mode='stretch_width'),\n                                   name='SCANPLOT - Editor de Texto', \n                                   contained=False, \n                                   position='center', \n                                   #margin=20,\n                                   config=config2)\n\n## Bot\xe3o do editor de textos\neditor_btn = pn.widgets.Button(name='\U0001f5d2\ufe0f Editor de Texto', button_type='primary')\n\n## Conte\xfado do di\xe1logo modal da paleta de cores\ncol_pallete1 = pn.pane.PNG('/extra3/SCANPLOT/jupyter/img/cp_uniform_sequential.png', width=1000)\ncol_pallete2 = pn.pane.PNG('/extra3/SCANPLOT/jupyter/img/cp_diverging.png', width=1000)\ncol_pallete3 = pn.pane.PNG('/extra3/SCANPLOT/jupyter/img/cp_rainbow.png', width=1000)\ncol_pallete4 = pn.pane.PNG('/extra3/SCANPLOT/jupyter/img/cp_categorical.png', width=1000)\ncol_pallete5 = pn.pane.PNG('/extra3/SCANPLOT/jupyter/img/cp_mono_sequential.png', width=1000)\ncol_pallete6 = pn.pane.PNG('/extra3/SCANPLOT/jupyter/img/cp_other_sequential.png', width=1000)\ncol_pallete7 = pn.pane.PNG('/extra3/SCANPLOT/jupyter/img/cp_miscellaneous.png', width=1000)\n\n## Abas do di\xe1logo modal da paleta de cores\ncolor_palletes_tabs = pn.Tabs(('Uniform Sequential', col_pallete1), \n                              ('Diverging', col_pallete2),\n                              ('Rainbow', col_pallete3),\n                              ('Categorical', col_pallete4),\n                              ('Mono Sequential', col_pallete5),\n                              ('Other Sequential', col_pallete6),\n                             )\n\n## Demais bot\xf5es dos outros di\xe1logos modais\nmodal_btn = pn.widgets.Button(name='\U0001f4d6 Informa\xe7\xf5es Gerais', button_type='primary')\nmodal_btn_fu = pn.widgets.Button(name='\U0001f4ca Sobre', button_type='success')\nmodal_btn_st = pn.widgets.Button(name='\U0001f4ca Sobre', button_type='success')\nmodal_btn_sc = pn.widgets.Button(name='\U0001f4ca Sobre', button_type='success')\nmodal_btn_ded = pn.widgets.Button(name='\U0001f4ca Sobre', button_type='success')\nmodal_help = pn.widgets.Button(name='\U0001f6df Ajuda', button_type='primary')\n\n## Cart\xf5es da barra lateral\ncard_parameters_fu = pn.Card(winpt, modal_btn_fu, title='Selecionar Cat\xe1logo', collapsed=False)\ncard_parameters_st = pn.Card(wst, modal_btn_st, title='S\xe9rie Temporal', collapsed=False)\ncard_parameters_sc = pn.Card(wsc, modal_btn_sc, title='Scorecard', collapsed=False)\ncard_parameters_ded = pn.Card(wded, modal_btn_ded, title='Distribui\xe7\xe3o Espacial', collapsed=False)\n\n#\n# IN\xcdCIO DO TEMPLATE\n#\n        \n## Inicializa o template (demais elementos como o conte\xfado da barra lateral, bot\xf5es, di\xe1logos modais, abas e \xe1rea principal s\xe3o adicionados depois)\ntemplate = pn.template.BootstrapTemplate(title = 'SCANPLOT V2.0.0a1', logo = scantec_logo)\n\n## Abas da \xe1rea principal (actvive=0 = define a primeira aba como ativa; dynamic=True = carrega as demais abas apenas quando forem clicadas)\ntabs = pn.Tabs(dynamic=True, active=0)\ntabs.append(('In\xedcio', welcomeText))\ntabs.append(('S\xe9rie Temporal', plotCurves))\ntabs.append(('Scorecard', plotScorecard))\ntabs.append(('Distribui\xe7\xe3o Espacial', plotFieldsDouble))\n\n## Adiciona um placeholder do modal \xe0 barra lateral\ntemplate.modal.append(pn.Column())\n\n## Textos dos di\xe1logos modais\ntext_info1 = pn.Column(text_gen_info)\ntext_info2 = pn.Column(text_st)\ntext_info3 = pn.Column(text_fu)\n\n## Inicaliza a barra lateral com o cart\xe3o do seletor de cat\xe1logos\ncol = pn.Column(card_parameters_fu)\n\n## Atualiza o conte\xfado da barra lateral de acordo com a aba ativa (utiliza o conte\xfado da primeira aba no in\xedcio)\n@pn.depends(tabs.param.active, watch=True)\ndef insert_widget(active_tab):\n    if active_tab == 0: \n        col[0] = card_parameters_fu\n        text_info3[0] = text_fu   \n    elif active_tab == 1: \n        col[0] = card_parameters_st\n        text_info2[0] = text_st\n    elif active_tab == 2: \n        col[0] = card_parameters_sc    \n        text_info2[0] = text_sc\n    elif active_tab == 3: \n        col[0] = card_parameters_ded\n        text_info2[0] = text_ded\n        \n## Fun\xe7\xf5es que definem quais bot\xf5es abrem quais di\xe1logos modais        \ndef show_modal_1(event):\n    template.modal[0].clear()\n    template.modal[0].append(text_info1)\n    template.open_modal()\n\ndef show_modal_2(event):\n    template.modal[0].clear()\n    template.modal[0].append(text_info2)\n    template.open_modal()    \n        \ndef show_modal_3(event):\n    template.modal[0].clear()\n    template.modal[0].append(pn.Column('# Paletas de Cores', 'Mais informa\xe7\xf5es em <a href="https://holoviews.org/user_guide/Colormaps.html" target="_blank">Colormaps</a>.', color_palletes_tabs))\n    template.open_modal()\n\ndef show_modal_4(event):\n    template.modal[0].clear()\n    template.modal[0].append(pn.Column(text_help))\n    template.open_modal()    \n    \ndef show_modal_5(event):\n    template.modal[0].clear()\n    template.modal[0].append(text_info3)\n    template.open_modal()      \n    \ndef show_text_editor(event):\n    placeholder[:] = [text_editor]    \n    \n## Callback dos bot\xf5es e di\xe1logos modais    \nmodal_btn.on_click(show_modal_1)\nmodal_btn_fu.on_click(show_modal_5) \nmodal_btn_st.on_click(show_modal_2)\nmodal_btn_sc.on_click(show_modal_2)\nmodal_btn_ded.on_click(show_modal_2)      \n\nshow_color_pallete.on_click(show_modal_3)    \nmodal_help.on_click(show_modal_4)    \neditor_btn.on_click(show_text_editor)\n  \nplaceholder = pn.Column(height=0, width=0)   \n    \ntemplate.sidebar.append(col)\ntemplate.sidebar.append(modal_btn)\ntemplate.sidebar.append(modal_help)\ntemplate.sidebar.append(editor_btn)\ntemplate.sidebar.append(silence)\ntemplate.sidebar.append('##### CPTEC-INPE, 2025.')\ntemplate.main.append(pn.Column(\n    tabs,    \n    float_panel, \n    placeholder,\n    pn.pane.Alert('\u26a0\ufe0f **Aviso:** As informa\xe7\xf5es aqui apresentadas n\xe3o representam informa\xe7\xf5es oficiais e n\xe3o devem ser utilizadas para a tomada de decis\xe3o.', alert_type='warning')\n    )\n)\n\ntemplate.servable();\n\n\nawait write_doc()
  `

  try {
    const [docs_json, render_items, root_ids] = await self.pyodide.runPythonAsync(code)
    self.postMessage({
      type: 'render',
      docs_json: docs_json,
      render_items: render_items,
      root_ids: root_ids
    })
  } catch(e) {
    const traceback = `${e}`
    const tblines = traceback.split('\n')
    self.postMessage({
      type: 'status',
      msg: tblines[tblines.length-2]
    });
    throw e
  }
}

self.onmessage = async (event) => {
  const msg = event.data
  if (msg.type === 'rendered') {
    self.pyodide.runPythonAsync(`
    from panel.io.state import state
    from panel.io.pyodide import _link_docs_worker

    _link_docs_worker(state.curdoc, sendPatch, setter='js')
    `)
  } else if (msg.type === 'patch') {
    self.pyodide.globals.set('patch', msg.patch)
    self.pyodide.runPythonAsync(`
    from panel.io.pyodide import _convert_json_patch
    state.curdoc.apply_json_patch(_convert_json_patch(patch), setter='js')
    `)
    self.postMessage({type: 'idle'})
  } else if (msg.type === 'location') {
    self.pyodide.globals.set('location', msg.location)
    self.pyodide.runPythonAsync(`
    import json
    from panel.io.state import state
    from panel.util import edit_readonly
    if state.location:
        loc_data = json.loads(location)
        with edit_readonly(state.location):
            state.location.param.update({
                k: v for k, v in loc_data.items() if k in state.location.param
            })
    `)
  }
}

startApplication()